# ADK API Reference

-----

# `google.adk.agents` module

## `google.adk.agents.Agent`

Alias of `LlmAgent`.

-----

## `google.adk.agents.BaseAgent`

Pydantic model.
Bases: `BaseModel`

Base class for all agents in Agent Development Kit.

Show JSON schema

**FIELDS:**

  * `after_agent_callback` (`Callable[[google.adk.agents.callback_context.CallbackContext],Awaitable[google.genai.types.Content | None] | google.genai.types.Content | None] | None`)
  * `before_agent_callback` (`Callable[[google.adk.agents.callback_context.CallbackContext],Awaitable[google.genai.types.Content | None] | google.genai.types.Content | None] | None`)
  * `description` (`str`)
  * `name` (`str`)
  * `parent_agent` (`google.adk.agents.base_agent.BaseAgent | None`)
  * `sub_agents` (`list[google.adk.agents.base_agent.BaseAgent]`)

**VALIDATORS:**

  * `__validate_name` » `name`

### `field after_agent_callback: Optional[AfterAgentCallback] = None`

Callback signature that is invoked after the agent run.

**PARAMETERS:**

  * `callback_context` – MUST be named ‘callback\_context’ (enforced).

**RETURNS:**

The content to return to the user. When the content is present, the provided content will be used as agent response and appended to event history as agent response.

**RETURN TYPE:**

`Optional[types.Content]`

### `field before_agent_callback: Optional[BeforeAgentCallback] = None`

Callback signature that is invoked before the agent run.

**PARAMETERS:**

  * `callback_context` – MUST be named ‘callback\_context’ (enforced).

**RETURNS:**

The content to return to the user. When the content is present, the agent run will be skipped and the provided content will be returned to user.

**RETURN TYPE:**

`Optional[types.Content]`

### `field description: str = ''`

Description about the agent’s capability.

The model uses this to determine whether to delegate control to the agent. One-line description is enough and preferred.

### `field name: str [Required]`

The agent’s name.

Agent name must be a Python identifier and unique within the agent tree. Agent name cannot be “user”, since it’s reserved for end-user’s input.

**VALIDATED BY:**

  * `__validate_name`

### `field parent_agent: Optional[BaseAgent] = None`

The parent agent of this agent.

Note that an agent can ONLY be added as sub-agent once. If you want to add one agent twice as sub-agent, consider to create two agent instances with identical config, but with different name and add them to the agent tree.

### `field sub_agents: list[BaseAgent] [Optional]`

The sub-agents of this agent.

### `find_agent(name)`

Finds the agent with the given name in this agent and its descendants.

**RETURN TYPE:**

`Optional[BaseAgent]`

**PARAMETERS:**

  * `name` – The name of the agent to find.

**RETURNS:**

The agent with the matching name, or `None` if no such agent is found.

### `find_sub_agent(name)`

Finds the agent with the given name in this agent’s descendants.

**RETURN TYPE:**

`Optional[BaseAgent]`

**PARAMETERS:**

  * `name` – The name of the agent to find.

**RETURNS:**

The agent with the matching name, or `None` if no such agent is found.

### `model_post_init(_BaseAgent__context)`

Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation that requires the entire model to be initialized.

**RETURN TYPE:**

`None`

### `async run_async(parent_context)`

Entry method to run an agent via text-based conversation.

**RETURN TYPE:**

`AsyncGenerator[Event, None]`

**PARAMETERS:**

  * `parent_context` – InvocationContext, the invocation context of the parent agent.

**YIELDS:**

`Event` – the events generated by the agent.

### `async run_live(parent_context)`

Entry method to run an agent via video/audio-based conversation.

**RETURN TYPE:**

`AsyncGenerator[Event, None]`

**PARAMETERS:**

  * `parent_context` – InvocationContext, the invocation context of the parent agent.

**YIELDS:**

`Event` – the events generated by the agent.

### `property root_agent: BaseAgent`

Gets the root agent of this agent.

-----

## `google.adk.agents.LlmAgent`

Pydantic model.
Bases: `BaseAgent`

LLM-based Agent.

Show JSON schema

**FIELDS:**

  * `after_model_callback` (`Optional[AfterModelCallback]`)
  * `after_tool_callback` (`Optional[AfterToolCallback]`)
  * `before_model_callback` (`Optional[BeforeModelCallback]`)
  * `before_tool_callback` (`Optional[BeforeToolCallback]`)
  * `code_executor` (`Optional[BaseCodeExecutor]`)
  * `disallow_transfer_to_parent` (`bool`)
  * `disallow_transfer_to_peers` (`bool`)
  * `examples` (`Optional[ExamplesUnion]`)
  * `generate_content_config` (`Optional[types.GenerateContentConfig]`)
  * `global_instruction` (`Union[str, InstructionProvider]`)
  * `include_contents` (`Literal['default', 'none']`)
  * `input_schema` (`Optional[type[BaseModel]]`)
  * `instruction` (`Union[str, InstructionProvider]`)
  * `model` (`Union[str, BaseLlm]`)
  * `output_key` (`Optional[str]`)
  * `output_schema` (`Optional[type[BaseModel]]`)
  * `planner` (`Optional[BasePlanner]`)
  * `tools` (`list[ToolUnion]`)

**VALIDATORS:**

  * `__model_validator_after` » `all fields`
  * `__validate_generate_content_config` » `generate_content_config`

### `field after_model_callback: Optional[AfterModelCallback] = None`

Callback or list of callbacks to be called after calling the LLM.

When a list of callbacks is provided, the callbacks will be called in the order they are listed until a callback does not return None.

**PARAMETERS:**

  * `callback_context` – CallbackContext,
  * `llm_response` – LlmResponse, the actual model response.

**RETURNS:**

The content to return to the user. When present, the actual model response will be ignored and the provided content will be returned to user.

**VALIDATED BY:**

  * `__model_validator_after`

### `field after_tool_callback: Optional[AfterToolCallback] = None`

Called after the tool is called.

**PARAMETERS:**

  * `tool` – The tool to be called.
  * `args` – The arguments to the tool.
  * `tool_context` – ToolContext,
  * `tool_response` – The response from the tool.

**RETURNS:**

When present, the returned dict will be used as tool result.

**VALIDATED BY:**

  * `__model_validator_after`

### `field before_model_callback: Optional[BeforeModelCallback] = None`

Callback or list of callbacks to be called before calling the LLM.

When a list of callbacks is provided, the callbacks will be called in the order they are listed until a callback does not return None.

**PARAMETERS:**

  * `callback_context` – CallbackContext,
  * `llm_request` – LlmRequest, The raw model request. Callback can mutate the request.

**RETURNS:**

The content to return to the user. When present, the model call will be skipped and the provided content will be returned to user.

**VALIDATED BY:**

  * `__model_validator_after`

### `field before_tool_callback: Optional[BeforeToolCallback] = None`

Called before the tool is called.

**PARAMETERS:**

  * `tool` – The tool to be called.
  * `args` – The arguments to the tool.
  * `tool_context` – ToolContext,

**RETURNS:**

The tool response. When present, the returned tool response will be used and the framework will skip calling the actual tool.

**VALIDATED BY:**

  * `__model_validator_after`

### `field code_executor: Optional[BaseCodeExecutor] = None`

Allow agent to execute code blocks from model responses using the provided CodeExecutor.

Check out available code executions in `google.adk.code_executor` package.

NOTE: to use model’s built-in code executor, don’t set this field, add `google.adk.tools.built_in_code_execution` to tools instead.

**VALIDATED BY:**

  * `__model_validator_after`

### `field disallow_transfer_to_parent: bool = False`

Disallows LLM-controlled transferring to the parent agent.

**VALIDATED BY:**

  * `__model_validator_after`

### `field disallow_transfer_to_peers: bool = False`

Disallows LLM-controlled transferring to the peer agents.

**VALIDATED BY:**

  * `__model_validator_after`

### `field examples: Optional[ExamplesUnion] = None`

**VALIDATED BY:**

  * `__model_validator_after`

### `field generate_content_config: Optional[types.GenerateContentConfig] = None`

The additional content generation configurations.

NOTE: not all fields are usable, e.g. tools must be configured via `tools`, thinking\_config must be configured via `planner` in LlmAgent.

For example: use this config to adjust model temperature, configure safety settings, etc.

**VALIDATED BY:**

  * `__model_validator_after`
  * `__validate_generate_content_config`

### `field global_instruction: Union[str, InstructionProvider] = ''`

Instructions for all the agents in the entire agent tree.

`global_instruction` ONLY takes effect in root agent.

For example: use `global_instruction` to make all agents have a stable identity or personality.

**VALIDATED BY:**

  * `__model_validator_after`

### `field include_contents: Literal['default', 'none'] = 'default'`

Whether to include contents in the model request.

When set to ‘none’, the model request will not include any contents, such as user messages, tool results, etc.

**VALIDATED BY:**

  * `__model_validator_after`

### `field input_schema: Optional[type[BaseModel]] = None`

The input schema when agent is used as a tool.

**VALIDATED BY:**

  * `__model_validator_after`

### `field instruction: Union[str, InstructionProvider] = ''`

Instructions for the LLM model, guiding the agent’s behavior.

**VALIDATED BY:**

  * `__model_validator_after`

### `field model: Union[str, BaseLlm] = ''`

The model to use for the agent.

When not set, the agent will inherit the model from its ancestor.

**VALIDATED BY:**

  * `__model_validator_after`

### `field output_key: Optional[str] = None`

The key in session state to store the output of the agent.

Typically use cases: - Extracts agent reply for later use, such as in tools, callbacks, etc. - Connects agents to coordinate with each other.

**VALIDATED BY:**

  * `__model_validator_after`

### `field output_schema: Optional[type[BaseModel]] = None`

The output schema when agent replies.

NOTE: when this is set, agent can ONLY reply and CANNOT use any tools, such as function tools, RAGs, agent transfer, etc.

**VALIDATED BY:**

  * `__model_validator_after`

### `field planner: Optional[BasePlanner] = None`

Instructs the agent to make a plan and execute it step by step.

NOTE: to use model’s built-in thinking features, set the `thinking_config` field in `google.adk.planners.built_in_planner`.

**VALIDATED BY:**

  * `__model_validator_after`

### `field tools: list[ToolUnion] [Optional]`

Tools available to this agent.

**VALIDATED BY:**

  * `__model_validator_after`

### `canonical_global_instruction(ctx)`

The resolved self.instruction field to construct global instruction.

This method is only for use by Agent Development Kit.

**RETURN TYPE:**

`str`

### `canonical_instruction(ctx)`

The resolved self.instruction field to construct instruction for this agent.

This method is only for use by Agent Development Kit.

**RETURN TYPE:**

`str`

### `property canonical_after_model_callbacks: list[Callable[[CallbackContext,LlmResponse], Awaitable[LlmResponse | None] | LlmResponse | None]]`

The resolved self.after\_model\_callback field as a list of \_SingleAfterModelCallback.

This method is only for use by Agent Development Kit.

### `property canonical_before_model_callbacks: list[Callable[[CallbackContext,LlmRequest], Awaitable[LlmResponse | None] | LlmResponse | None]]`

The resolved self.before\_model\_callback field as a list of \_SingleBeforeModelCallback.

This method is only for use by Agent Development Kit.

### `property canonical_model: BaseLlm`

The resolved self.model field as BaseLlm.

This method is only for use by Agent Development Kit.

### `property canonical_tools: list[BaseTool]`

The resolved self.tools field as a list of BaseTool.

This method is only for use by Agent Development Kit.

-----

## `google.adk.agents.LoopAgent`

Pydantic model.
Bases: `BaseAgent`

A shell agent that run its sub-agents in a loop.

When sub-agent generates an event with escalate or max\_iterations are reached, the loop agent will stop.

Show JSON schema

**FIELDS:**

  * `max_iterations` (`Optional[int]`)

**VALIDATORS:**

None

### `field max_iterations: Optional[int] = None`

The maximum number of iterations to run the loop agent.

If not set, the loop agent will run indefinitely until a sub-agent escalates.

-----

## `google.adk.agents.ParallelAgent`

Pydantic model.
Bases: `BaseAgent`

A shell agent that run its sub-agents in parallel in isolated manner.

This approach is beneficial for scenarios requiring multiple perspectives or attempts on a single task, such as:

  * Running different algorithms simultaneously.
  * Generating multiple responses for review by a subsequent evaluation agent.

Show JSON schema

**FIELDS:**

None

**VALIDATORS:**

None

-----

## `google.adk.agents.SequentialAgent`

Pydantic model.
Bases: `BaseAgent`

A shell agent that run its sub-agents in sequence.

Show JSON schema

**FIELDS:**

None

**VALIDATORS:**

None

-----

# `google.adk.artifacts` module

## `class google.adk.artifacts.BaseArtifactService`

Bases: `ABC`

Abstract base class for artifact services.

### `abstractmethod async delete_artifact(*, app_name, user_id, session_id, filename)`

Deletes an artifact.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.
  * `filename` – The name of the artifact file.

### `abstractmethod async list_artifact_keys(*, app_name, user_id, session_id)`

Lists all the artifact filenames within a session.

**RETURN TYPE:**

`list[str]`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.

**RETURNS:**

A list of all artifact filenames within a session.

### `abstractmethod async list_versions(*, app_name, user_id, session_id, filename)`

Lists all versions of an artifact.

**RETURN TYPE:**

`list[int]`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.
  * `filename` – The name of the artifact file.

**RETURNS:**

A list of all available versions of the artifact.

### `abstractmethod async load_artifact(*, app_name, user_id, session_id, filename, version=None)`

Gets an artifact from the artifact service storage.

The artifact is a file identified by the app name, user ID, session ID, and filename.

**RETURN TYPE:**

`Optional[Part]`

**PARAMETERS:**

  * `app_name` – The app name.
  * `user_id` – The user ID.
  * `session_id` – The session ID.
  * `filename` – The filename of the artifact.
  * `version` – The version of the artifact. If None, the latest version will be returned.

**RETURNS:**

The artifact or `None` if not found.

### `abstractmethod async save_artifact(*, app_name, user_id, session_id, filename, artifact)`

Saves an artifact to the artifact service storage.

The artifact is a file identified by the app name, user ID, session ID, and filename. After saving the artifact, a revision ID is returned to identify the artifact version.

**RETURN TYPE:**

`int`

**PARAMETERS:**

  * `app_name` – The app name.
  * `user_id` – The user ID.
  * `session_id` – The session ID.
  * `filename` – The filename of the artifact.
  * `artifact` – The artifact to save.

**RETURNS:**

The revision ID. The first version of the artifact has a revision ID of 0. This is incremented by 1 after each successful save.

## `class google.adk.artifacts.GcsArtifactService(bucket_name, **kwargs)`

Bases: `BaseArtifactService`

An artifact service implementation using Google Cloud Storage (GCS).

Initializes the GcsArtifactService.

**PARAMETERS:**

  * `bucket_name` – The name of the bucket to use.
  * `**kwargs` – Keyword arguments to pass to the Google Cloud Storage client.

### `async delete_artifact(*, app_name, user_id, session_id, filename)`

Deletes an artifact.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.
  * `filename` – The name of the artifact file.

### `async list_artifact_keys(*, app_name, user_id, session_id)`

Lists all the artifact filenames within a session.

**RETURN TYPE:**

`list[str]`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.

**RETURNS:**

A list of all artifact filenames within a session.

### `async list_versions(*, app_name, user_id, session_id, filename)`

Lists all versions of an artifact.

**RETURN TYPE:**

`list[int]`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.
  * `filename` – The name of the artifact file.

**RETURNS:**

A list of all available versions of the artifact.

### `async load_artifact(*, app_name, user_id, session_id, filename, version=None)`

Gets an artifact from the artifact service storage.

The artifact is a file identified by the app name, user ID, session ID, and filename.

**RETURN TYPE:**

`Optional[Part]`

**PARAMETERS:**

  * `app_name` – The app name.
  * `user_id` – The user ID.
  * `session_id` – The session ID.
  * `filename` – The filename of the artifact.
  * `version` – The version of the artifact. If None, the latest version will be returned.

**RETURNS:**

The artifact or `None` if not found.

### `async save_artifact(*, app_name, user_id, session_id, filename, artifact)`

Saves an artifact to the artifact service storage.

The artifact is a file identified by the app name, user ID, session ID, and filename. After saving the artifact, a revision ID is returned to identify the artifact version.

**RETURN TYPE:**

`int`

**PARAMETERS:**

  * `app_name` – The app name.
  * `user_id` – The user ID.
  * `session_id` – The session ID.
  * `filename` – The filename of the artifact.
  * `artifact` – The artifact to save.

**RETURNS:**

The revision ID. The first version of the artifact has a revision ID of 0. This is incremented by 1 after each successful save.

-----

## `google.adk.artifacts.InMemoryArtifactService`

Pydantic model.
Bases: `BaseArtifactService`, `BaseModel`

An in-memory implementation of the artifact service.

Show JSON schema

**FIELDS:**

  * `artifacts` (`dict[str, list[google.genai.types.Part]]`)

### `field artifacts: dict[str, list[Part]] [Optional]`

### `async delete_artifact(*, app_name, user_id, session_id, filename)`

Deletes an artifact.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.
  * `filename` – The name of the artifact file.

### `async list_artifact_keys(*, app_name, user_id, session_id)`

Lists all the artifact filenames within a session.

**RETURN TYPE:**

`list[str]`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.

**RETURNS:**

A list of all artifact filenames within a session.

### `async list_versions(*, app_name, user_id, session_id, filename)`

Lists all versions of an artifact.

**RETURN TYPE:**

`list[int]`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The ID of the user.
  * `session_id` – The ID of the session.
  * `filename` – The name of the artifact file.

**RETURNS:**

A list of all available versions of the artifact.

### `async load_artifact(*, app_name, user_id, session_id, filename, version=None)`

Gets an artifact from the artifact service storage.

The artifact is a file identified by the app name, user ID, session ID, and filename.

**RETURN TYPE:**

`Optional[Part]`

**PARAMETERS:**

  * `app_name` – The app name.
  * `user_id` – The user ID.
  * `session_id` – The session ID.
  * `filename` – The filename of the artifact.
  * `version` – The version of the artifact. If None, the latest version will be returned.

**RETURNS:**

The artifact or `None` if not found.

### `async save_artifact(*, app_name, user_id, session_id, filename, artifact)`

Saves an artifact to the artifact service storage.

The artifact is a file identified by the app name, user ID, session ID, and filename. After saving the artifact, a revision ID is returned to identify the artifact version.

**RETURN TYPE:**

`int`

**PARAMETERS:**

  * `app_name` – The app name.
  * `user_id` – The user ID.
  * `session_id` – The session ID.
  * `filename` – The filename of the artifact.
  * `artifact` – The artifact to save.

**RETURNS:**

The revision ID. The first version of the artifact has a revision ID of 0. This is incremented by 1 after each successful save.

-----

# `google.adk.code_executors` module

## `google.adk.code_executors.BaseCodeExecutor`

Pydantic model.
Bases: `BaseModel`

Abstract base class for all code executors.

The code executor allows the agent to execute code blocks from model responses and incorporate the execution results into the final response.

**Attributes:**

  * `optimize_data_file`: If true, extract and process data files from the model request and attach them to the code executor. Supported data file MimeTypes are `[text/csv]`. Default to `False`.
  * `stateful`: Whether the code executor is stateful. Default to `False`.
  * `error_retry_attempts`: The number of attempts to retry on consecutive code execution errors. Default to 2.
  * `code_block_delimiters`: The list of the enclosing delimiters to identify the code blocks.
  * `execution_result_delimiters`: The delimiters to format the code execution result.

Show JSON schema

**FIELDS:**

  * `code_block_delimiters` (`List[tuple[str, str]]`)
  * `error_retry_attempts` (`int`)
  * `execution_result_delimiters` (`tuple[str, str]`)
  * `optimize_data_file` (`bool`)
  * `stateful` (`bool`)

### \`field code\_block\_delimiters: List[tuple[str, str]] = [('

````python
tool_code\n', '\n```')]
The list of the enclosing delimiters to identify the code blocks. For example, the delimiter `('```python\n', '\n```')` can be used to identify code blocks with the following format:

```python
print("hello")
````

### `field error_retry_attempts: int = 2`

The number of attempts to retry on consecutive code execution errors. Default to 2.

### `field execution_result_delimiters: tuple[str, str] = ('```tool_output\n', '\n```')`

The delimiters to format the code execution result.

### `field optimize_data_file: bool = False`

If true, extract and process data files from the model request and attach them to the code executor. Supported data file MimeTypes are `[text/csv]`. Default to `False`.

### `field stateful: bool = False`

Whether the code executor is stateful. Default to `False`.

### `abstractmethod execute_code(invocation_context, code_execution_input)`

Executes code and return the code execution result.

**RETURN TYPE:**

`CodeExecutionResult`

**PARAMETERS:**

  * `invocation_context` – The invocation context of the code execution.
  * `code_execution_input` – The code execution input.

**RETURNS:**

The code execution result.

-----

## `class google.adk.code_executors.CodeExecutorContext(session_state)`

Bases: `object`

The persistent context used to configure the code executor.

Initializes the code executor context.

**PARAMETERS:**

  * `session_state` – The session state to get the code executor context from.

### `add_input_files(input_files)`

Adds the input files to the code executor context.

**PARAMETERS:**

  * `input_files` – The input files to add to the code executor context.

### `add_processed_file_names(file_names)`

Adds the processed file name to the session state.

**PARAMETERS:**

  * `file_names` – The processed file names to add to the session state.

### `clear_input_files()`

Removes the input files and processed file names to the code executor context.

### `get_error_count(invocation_id)`

Gets the error count from the session state.

**RETURN TYPE:**

`int`

**PARAMETERS:**

  * `invocation_id` – The invocation ID to get the error count for.

**RETURNS:**

The error count for the given invocation ID.

### `get_execution_id()`

Gets the session ID for the code executor.

**RETURN TYPE:**

`Optional[str]`

**RETURNS:**

The session ID for the code executor context.

### `get_input_files()`

Gets the code executor input file names from the session state.

**RETURN TYPE:**

`list[File]`

**RETURNS:**

A list of input files in the code executor context.

### `get_processed_file_names()`

Gets the processed file names from the session state.

**RETURN TYPE:**

`list[str]`

**RETURNS:**

A list of processed file names in the code executor context.

### `get_state_delta()`

Gets the state delta to update in the persistent session state.

**RETURN TYPE:**

`dict[str, Any]`

**RETURNS:**

The state delta to update in the persistent session state.

### `increment_error_count(invocation_id)`

Increments the error count from the session state.

**PARAMETERS:**

  * `invocation_id` – The invocation ID to increment the error count for.

### `reset_error_count(invocation_id)`

Resets the error count from the session state.

**PARAMETERS:**

  * `invocation_id` – The invocation ID to reset the error count for.

### `set_execution_id(session_id)`

Sets the session ID for the code executor.

**PARAMETERS:**

  * `session_id` – The session ID for the code executor.

### `update_code_execution_result(invocation_id, code, result_stdout, result_stderr)`

Updates the code execution result.

**PARAMETERS:**

  * `invocation_id` – The invocation ID to update the code execution result for.
  * `code` – The code to execute.
  * `result_stdout` – The standard output of the code execution.
  * `result_stderr` – The standard error of the code execution.

-----

## `google.adk.code_executors.ContainerCodeExecutor`

Pydantic model.
Bases: `BaseCodeExecutor`

A code executor that uses a custom container to execute code.

**Attributes:**

  * `base_url`: Optional. The base url of the user hosted Docker client.
  * `image`: The tag of the predefined image or custom image to run on the container. Either docker\_path or image must be set.
  * `docker_path`: The path to the directory containing the Dockerfile. If set, build the image from the dockerfile path instead of using the predefined image. Either docker\_path or image must be set.

Initializes the ContainerCodeExecutor.

**PARAMETERS:**

  * `base_url` – Optional. The base url of the user hosted Docker client.
  * `image` – The tag of the predefined image or custom image to run on the container. Either `docker_path` or `image` must be set.
  * `docker_path` – The path to the directory containing the Dockerfile. If set, build the image from the dockerfile path instead of using the predefined image. Either `docker_path` or `image` must be set.
  * `**data` – The data to initialize the ContainerCodeExecutor.

Show JSON schema

**FIELDS:**

  * `base_url` (`str | None`)
  * `docker_path` (`str`)
  * `image` (`str`)
  * `optimize_data_file` (`bool`)
  * `stateful` (`bool`)

### `field base_url: Optional[str] = None`

Optional. The base url of the user hosted Docker client.

### `field docker_path: str = None`

The path to the directory containing the Dockerfile. If set, build the image from the dockerfile path instead of using the predefined image. Either `docker_path` or `image` must be set.

### `field image: str = None`

The tag of the predefined image or custom image to run on the container. Either `docker_path` or `image` must be set.

### `field optimize_data_file: bool = False`

If true, extract and process data files from the model request and attach them to the code executor. Supported data file MimeTypes are `[text/csv]`. Default to `False`.

### `field stateful: bool = False`

Whether the code executor is stateful. Default to `False`.

### `execute_code(invocation_context, code_execution_input)`

Executes code and return the code execution result.

**RETURN TYPE:**

`CodeExecutionResult`

**PARAMETERS:**

  * `invocation_context` – The invocation context of the code execution.
  * `code_execution_input` – The code execution input.

**RETURNS:**

The code execution result.

### `model_post_init(context, /)`

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `self` – The BaseModel instance.
  * `context` – The context.

-----

## `google.adk.code_executors.UnsafeLocalCodeExecutor`

Pydantic model.
Bases: `BaseCodeExecutor`

A code executor that unsafely execute code in the current local context.

Initializes the UnsafeLocalCodeExecutor.

Show JSON schema

**FIELDS:**

  * `optimize_data_file` (`bool`)
  * `stateful` (`bool`)

### `field optimize_data_file: bool = False`

If true, extract and process data files from the model request and attach them to the code executor. Supported data file MimeTypes are `[text/csv]`. Default to `False`.

### `field stateful: bool = False`

Whether the code executor is stateful. Default to `False`.

### `execute_code(invocation_context, code_execution_input)`

Executes code and return the code execution result.

**RETURN TYPE:**

`CodeExecutionResult`

**PARAMETERS:**

  * `invocation_context` – The invocation context of the code execution.
  * `code_execution_input` – The code execution input.

**RETURNS:**

The code execution result.

-----

## `google.adk.code_executors.VertexAiCodeExecutor`

Pydantic model.
Bases: `BaseCodeExecutor`

A code executor that uses Vertex Code Interpreter Extension to execute code.

**Attributes:**

  * `resource_name`: If set, load the existing resource name of the code interpreter extension instead of creating a new one. Format: `projects/123/locations/us-central1/extensions/456`

Initializes the VertexAiCodeExecutor.

**PARAMETERS:**

  * `resource_name` – If set, load the existing resource name of the code interpreter extension instead of creating a new one. Format: `projects/123/locations/us-central1/extensions/456`
  * `**data` – Additional keyword arguments to be passed to the base class.

Show JSON schema

**FIELDS:**

  * `resource_name` (`str`)

### `field resource_name: str = None`

If set, load the existing resource name of the code interpreter extension instead of creating a new one. Format: `projects/123/locations/us-central1/extensions/456`

### `execute_code(invocation_context, code_execution_input)`

Executes code and return the code execution result.

**RETURN TYPE:**

`CodeExecutionResult`

**PARAMETERS:**

  * `invocation_context` – The invocation context of the code execution.
  * `code_execution_input` – The code execution input.

**RETURNS:**

The code execution result.

### `model_post_init(context, /)`

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `self` – The BaseModel instance.
  * `context` – The context.

-----

# `google.adk.evaluation` module

## `class google.adk.evaluation.AgentEvaluator`

Bases: `object`

An evaluator for Agents, mainly intended for helping with test cases.

### `static evaluate(agent_module, eval_dataset_file_path_or_dir, num_runs=2, agent_name=None, initial_session_file=None)`

Evaluates an Agent given eval data.

**PARAMETERS:**

  * `agent_module` – The path to python module that contains the definition of the agent. There is convention in place here, where the code is going to look for ‘root\_agent’ in the loaded module.
  * `eval_dataset` – The eval data set. This can be either a string representing full path to the file containing eval dataset, or a directory that is recursively explored for all files that have a `.test.json` suffix.
  * `num_runs` – Number of times all entries in the eval dataset should be assessed.
  * `agent_name` – The name of the agent.
  * `initial_session_file` – File that contains initial session state that is needed by all the evals in the eval dataset.

### `static find_config_for_test_file(test_file)`

Find the test\_config.json file in the same folder as the test file.

-----

# `google.adk.events` module

## `google.adk.events.Event`

Pydantic model.
Bases: `LlmResponse`

Represents an event in a conversation between agents and users.

It is used to store the content of the conversation, as well as the actions taken by the agents like function calls, etc.

**Attributes:**

  * `invocation_id`: The invocation ID of the event.
  * `author`: “user” or the name of the agent, indicating who appended the event to the session.
  * `actions`: The actions taken by the agent.
  * `long_running_tool_ids`: The ids of the long running function calls.
  * `branch`: The branch of the event.
  * `id`: The unique identifier of the event.
  * `timestamp`: The timestamp of the event.
  * `is_final_response`: Whether the event is the final response of the agent.
  * `get_function_calls`: Returns the function calls in the event.

Show JSON schema

**FIELDS:**

  * `actions` (`google.adk.events.event_actions.EventActions`)
  * `author` (`str`)
  * `branch` (`str | None`)
  * `id` (`str`)
  * `invocation_id` (`str`)
  * `long_running_tool_ids` (`set[str] | None`)
  * `timestamp` (`float`)

### `field actions: EventActions [Optional]`

The actions taken by the agent.

### `field author: str [Required]`

‘user’ or the name of the agent, indicating who appended the event to the session.

### `field branch: Optional[str] = None`

The branch of the event.

The format is like `agent_1.agent_2.agent_3`, where `agent_1` is the parent of `agent_2`, and `agent_2` is the parent of `agent_3`.

Branch is used when multiple sub-agent shouldn’t see their peer agents’ conversation history.

### `field id: str = ''`

The unique identifier of the event.

### `field invocation_id: str = ''`

The invocation ID of the event.

### `field long_running_tool_ids: Optional[set[str]] = None`

Set of ids of the long running function calls. Agent client will know from this field about which function call is long running. only valid for function call event

### `field timestamp: float [Optional]`

The timestamp of the event.

### `static new_id()`

### `get_function_calls()`

Returns the function calls in the event.

**RETURN TYPE:**

`list[FunctionCall]`

### `get_function_responses()`

Returns the function responses in the event.

**RETURN TYPE:**

`list[FunctionResponse]`

### `has_trailing_code_execution_result()`

Returns whether the event has a trailing code execution result.

**RETURN TYPE:**

`bool`

### `is_final_response()`

Returns whether the event is the final response of the agent.

**RETURN TYPE:**

`bool`

### `model_post_init(_Event__context)`

Post initialization logic for the event.

-----

## `google.adk.events.EventActions`

Pydantic model.
Bases: `BaseModel`

Represents the actions attached to an event.

Show JSON schema

**FIELDS:**

  * `artifact_delta` (`dict[str, int]`)
  * `escalate` (`bool | None`)
  * `requested_auth_configs` (`dict[str, google.adk.auth.auth_tool.AuthConfig]`)
  * `skip_summarization` (`bool | None`)
  * `state_delta` (`dict[str, object]`)
  * `transfer_to_agent` (`str | None`)

### `field artifact_delta: dict[str, int] [Optional]`

        Indicates that the event is updating an artifact. key is the filename, value is the version.

### `field escalate: Optional[bool] = None`
The agent is escalating to a higher level agent.

### `field requested_auth_configs: dict[str, AuthConfig] [Optional]`
Authentication configurations requested by tool responses.

This field will only be set by a tool response event indicating tool request auth credential. - Keys: The function call id. Since one function response event could contain multiple function responses that correspond to multiple function calls. Each function call could request different auth configs. This id is used to identify the function call. - Values: The requested auth config.

### `field skip_summarization: Optional[bool] = None`
If true, it won’t call model to summarize function response.

Only used for function_response event.

### `field state_delta: dict[str, object] [Optional]`
Indicates that the event is updating the state with the given delta.

### `field transfer_to_agent: Optional[str] = None`
If set, the event transfers to the specified agent.


-----

# `google.adk.examples` module

-----

## `class google.adk.examples.BaseExampleProvider`

Bases: `ABC`

Base class for example providers.

This class defines the interface for providing examples for a given query.

### `abstractmethod get_examples(query)`

Returns a list of examples for a given query.

**RETURN TYPE:**

`list[Example]`

**PARAMETERS:**

  * `query` – The query to get examples for.

**RETURNS:**

A list of Example objects.

-----

## `pydantic model google.adk.examples.Example`

Bases: `BaseModel`

A few-shot example.

### `input`

The input content for the example.

### `output`

The expected output content for the example.

Show JSON schema

**FIELDS:**

  * `input` (`google.genai.types.Content`)
  * `output` (`list[google.genai.types.Content]`)

### `field input: Content [Required]`

### `field output: list[Content] [Required]`

-----

## `class google.adk.examples.VertexAiExampleStore(examples_store_name)`

Bases: `BaseExampleProvider`

Provides examples from Vertex example store.

Initializes the VertexAiExampleStore.

**PARAMETERS:**

  * `examples_store_name` – The resource name of the vertex example store, in the format of
    `projects/{project}/locations/{location}/exampleStores/{example_store}`.

### `get_examples(query)`

Returns a list of examples for a given query.

**RETURN TYPE:**

`list[Example]`

**PARAMETERS:**

  * `query` – The query to get examples for.

**RETURNS:**

A list of Example objects.

-----

# `google.adk.memory` module

-----

## `class google.adk.memory.BaseMemoryService`

Bases: `ABC`

Base class for memory services.

The service provides functionalities to ingest sessions into memory so that the memory can be used for user queries.

### `abstractmethod async add_session_to_memory(session)`

Adds a session to the memory service.

A session may be added multiple times during its lifetime.

**PARAMETERS:**

  * `session` – The session to add.

### `abstractmethod async search_memory(*, app_name, user_id, query)`

Searches for sessions that match the query.

**RETURN TYPE:**

`SearchMemoryResponse`

**PARAMETERS:**

  * `app_name` – The name of the application.
  * `user_id` – The id of the user.
  * `query` – The query to search for.

**RETURNS:**

A SearchMemoryResponse containing the matching memories.

-----

## `class google.adk.memory.InMemoryMemoryService`

Bases: `BaseMemoryService`

An in-memory memory service for prototyping purpose only.

Uses keyword matching instead of semantic search.

### `async add_session_to_memory(session)`

Adds a session to the memory service.

A session may be added multiple times during its lifetime.

**PARAMETERS:**

  * `session` – The session to add.

### `async search_memory(*, app_name, user_id, query)`

Prototyping purpose only.

**RETURN TYPE:**

`SearchMemoryResponse`

### `session_events: dict[str, list[Event]]`

keys are app\_name/user\_id/session\_id

-----

## `class google.adk.memory.VertexAiRagMemoryService(rag_corpus=None, similarity_top_k=None, vector_distance_threshold=10)`

Bases: `BaseMemoryService`

A memory service that uses Vertex AI RAG for storage and retrieval.

Initializes a VertexAiRagMemoryService.

**PARAMETERS:**

  * `rag_corpus` – The name of the Vertex AI RAG corpus to use. Format:
    `projects/{project}/locations/{location}/ragCorpora/{rag_corpus_id}` or `{rag_corpus_id}`
  * `similarity_top_k` – The number of contexts to retrieve.
  * `vector_distance_threshold` – Only returns contexts with vector distance smaller than the threshold..

### `async add_session_to_memory(session)`

Adds a session to the memory service.

A session may be added multiple times during its lifetime.

**PARAMETERS:**

  * `session` – The session to add.

### `async search_memory(*, app_name, user_id, query)`

Searches for sessions that match the query using rag.retrieval\_query.

**RETURN TYPE:**

`SearchMemoryResponse`

-----

# `google.adk.models` module

-----

Defines the interface to support a model.

## `pydantic model google.adk.models.BaseLlm`

Bases: `BaseModel`

The BaseLLM class.

### `model`

The name of the LLM, e.g. gemini-1.5-flash or gemini-1.5-flash-001.

Show JSON schema

**FIELDS:**

  * `model` (`str`)

### `field model: str [Required]`

The name of the LLM, e.g. gemini-1.5-flash or gemini-1.5-flash-001.

### `classmethod supported_models()`

Returns a list of supported models in regex for LlmRegistry.

**RETURN TYPE:**

`list[str]`

### `connect(llm_request)`

Creates a live connection to the LLM.

**RETURN TYPE:**

`BaseLlmConnection`

**PARAMETERS:**

  * `llm_request` – LlmRequest, the request to send to the LLM.

**RETURNS:**

BaseLlmConnection, the connection to the LLM.

### `abstractmethod async generate_content_async(llm_request, stream=False)`

Generates one content from the given contents and tools.

**RETURN TYPE:**

`AsyncGenerator[LlmResponse, None]`

**PARAMETERS:**

  * `llm_request` – LlmRequest, the request to send to the LLM.
  * `stream` – `bool` = False, whether to do streaming call.

**YIELDS:**

a generator of types.Content. For non-streaming call, it will only yield one Content. For streaming call, it may yield more than one content, but all yielded contents should be treated as one content by merging the parts list.

-----

## `pydantic model google.adk.models.Gemini`

Bases: `BaseLlm`

Integration for Gemini models.

### `model`

The name of the Gemini model.

Show JSON schema

**FIELDS:**

  * `model` (`str`)

### `field model: str = 'gemini-1.5-flash'`

The name of the LLM, e.g. gemini-1.5-flash or gemini-1.5-flash-001.

### `static supported_models()`

Provides the list of supported models.

**RETURN TYPE:**

`list[str]`

**RETURNS:**

A list of supported models.

### `connect(llm_request)`

Connects to the Gemini model and returns an llm connection.

**RETURN TYPE:**

`BaseLlmConnection`

**PARAMETERS:**

  * `llm_request` – LlmRequest, the request to send to the Gemini model.

**YIELDS:**

BaseLlmConnection, the connection to the Gemini model.

### `async generate_content_async(llm_request, stream=False)`

Sends a request to the Gemini model.

**RETURN TYPE:**

`AsyncGenerator[LlmResponse, None]`

**PARAMETERS:**

  * `llm_request` – LlmRequest, the request to send to the Gemini model.
  * `stream` – `bool` = False, whether to do streaming call.

**YIELDS:**

`LlmResponse` – The model response.

### `property api_client: Client`

Provides the api client.

**RETURNS:**

The api client.

-----

## `class google.adk.models.LLMRegistry`

Bases: `object`

Registry for LLMs.

### `static new_llm(model)`

Creates a new LLM instance.

**RETURN TYPE:**

`BaseLlm`

**PARAMETERS:**

  * `model` – The model name.

**RETURNS:**

The LLM instance.

### `static register(llm_cls)`

Registers a new LLM class.

**PARAMETERS:**

  * `llm_cls` – The class that implements the model.

### `static resolve(model)`

Resolves the model to a BaseLlm subclass.

**RETURN TYPE:**

`type[BaseLlm]`

**PARAMETERS:**

  * `model` – The model name.

**RETURNS:**

The BaseLlm subclass.

**RAISES:**

`ValueError` – If the model is not found.

-----

# `google.adk.planners` module

-----

## `class google.adk.planners.BasePlanner`

Bases: `ABC`

Abstract base class for all planners.

The planner allows the agent to generate plans for the queries to guide its action.

### `abstractmethod build_planning_instruction(readonly_context, llm_request)`

Builds the system instruction to be appended to the LLM request for planning.

**RETURN TYPE:**

`Optional[str]`

**PARAMETERS:**

  * `readonly_context` – The readonly context of the invocation.
  * `llm_request` – The LLM request. Readonly.

**RETURNS:**

The planning system instruction, or None if no instruction is needed.

### `abstractmethod process_planning_response(callback_context, response_parts)`

Processes the LLM response for planning.

**RETURN TYPE:**

`Optional[List[Part]]`

**PARAMETERS:**

  * `callback_context` – The callback context of the invocation.
  * `response_parts` – The LLM response parts. Readonly.

**RETURNS:**

The processed response parts, or None if no processing is needed.

-----

## `class google.adk.planners.BuiltInPlanner(*, thinking_config)`

Bases: `BasePlanner`

The built-in planner that uses model’s built-in thinking features.

### `thinking_config`

Config for model built-in thinking features. An error will be returned if this field is set for models that don’t support thinking.

Initializes the built-in planner.

**PARAMETERS:**

  * `thinking_config` – Config for model built-in thinking features. An error will be returned if this field is set for models that don’t support thinking.

### `apply_thinking_config(llm_request)`

Applies the thinking config to the LLM request.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `llm_request` – The LLM request to apply the thinking config to.

### `build_planning_instruction(readonly_context, llm_request)`

Builds the system instruction to be appended to the LLM request for planning.

**RETURN TYPE:**

`Optional[str]`

**PARAMETERS:**

  * `readonly_context` – The readonly context of the invocation.
  * `llm_request` – The LLM request. Readonly.

**RETURNS:**

The planning system instruction, or None if no instruction is needed.

### `process_planning_response(callback_context, response_parts)`

Processes the LLM response for planning.

**RETURN TYPE:**

`Optional[List[Part]]`

**PARAMETERS:**

  * `callback_context` – The callback context of the invocation.
  * `response_parts` – The LLM response parts. Readonly.

**RETURNS:**

The processed response parts, or None if no processing is needed.

### `thinking_config: ThinkingConfig`

Config for model built-in thinking features. An error will be returned if this field is set for models that don’t support thinking.

-----

## `class google.adk.planners.PlanReActPlanner`

Bases: `BasePlanner`

Plan-Re-Act planner that constrains the LLM response to generate a plan before any action/observation.

Note: this planner does not require the model to support built-in thinking features or setting the thinking config.

### `build_planning_instruction(readonly_context, llm_request)`

Builds the system instruction to be appended to the LLM request for planning.

**RETURN TYPE:**

`str`

**PARAMETERS:**

  * `readonly_context` – The readonly context of the invocation.
  * `llm_request` – The LLM request. Readonly.

**RETURNS:**

The planning system instruction, or None if no instruction is needed.

### `process_planning_response(callback_context, response_parts)`

Processes the LLM response for planning.

**RETURN TYPE:**

`Optional[List[Part]]`

**PARAMETERS:**

  * `callback_context` – The callback context of the invocation.
  * `response_parts` – The LLM response parts. Readonly.

**RETURNS:**

The processed response parts, or None if no processing is needed.

-----

# `google.adk.runners` module

-----

## `class google.adk.runners.InMemoryRunner(agent, *, app_name='InMemoryRunner')`

Bases: `Runner`

An in-memory Runner for testing and development.

This runner uses in-memory implementations for artifact, session, and memory services, providing a lightweight and self-contained environment for agent execution.

### `agent`

The root agent to run.

### `app_name`

The application name of the runner. Defaults to ‘InMemoryRunner’.

Initializes the InMemoryRunner.

**PARAMETERS:**

  * `agent` – The root agent to run.
  * `app_name` – The application name of the runner. Defaults to ‘InMemoryRunner’.

-----

## `class google.adk.runners.Runner(*, app_name, agent, artifact_service=None, session_service, memory_service=None)`

Bases: `object`

The Runner class is used to run agents.

It manages the execution of an agent within a session, handling message processing, event generation, and interaction with various services like artifact storage, session management, and memory.

### `app_name`

The application name of the runner.

### `agent`

The root agent to run.

### `artifact_service`

The artifact service for the runner.

### `session_service`

The session service for the runner.

### `memory_service`

The memory service for the runner.

Initializes the Runner.

**PARAMETERS:**

  * `app_name` – The application name of the runner.
  * `agent` – The root agent to run.
  * `artifact_service` – The artifact service for the runner.
  * `session_service` – The session service for the runner.
  * `memory_service` – The memory service for the runner.

### `agent: BaseAgent`

The root agent to run.

### `app_name: str`

The app name of the runner.

### `artifact_service: Optional[BaseArtifactService] = None`

The artifact service for the runner.

### `async close_session(session)`

Closes a session and adds it to the memory service (experimental feature).

**PARAMETERS:**

  * `session` – The session to close.

### `memory_service: Optional[BaseMemoryService] = None`

The memory service for the runner.

### `run(*, user_id, session_id, new_message, run_config=RunConfig(speech_config=None, response_modalities=None, save_input_blobs_as_artifacts=False, support_cfc=False, streaming_mode=<StreamingMode.NONE: None>, output_audio_transcription=None, input_audio_transcription=None, max_llm_calls=500))`

Runs the agent.

NOTE: This sync interface is only for local testing and convenience purpose. Consider using `run_async` for production usage.

**RETURN TYPE:**

`Generator[Event, None, None]`

**PARAMETERS:**

  * `user_id` – The user ID of the session.
  * `session_id` – The session ID of the session.
  * `new_message` – A new message to append to the session.
  * `run_config` – The run config for the agent.

**YIELDS:**

The events generated by the agent.

### `async run_async(*, user_id, session_id, new_message, run_config=RunConfig(speech_config=None, response_modalities=None, save_input_blobs_as_artifacts=False, support_cfc=False, streaming_mode=<StreamingMode.NONE: None>, output_audio_transcription=None, input_audio_transcription=None, max_llm_calls=500))`

Main entry method to run the agent in this runner.

**RETURN TYPE:**

`AsyncGenerator[Event, None]`

**PARAMETERS:**

  * `user_id` – The user ID of the session.
  * `session_id` – The session ID of the session.
  * `new_message` – A new message to append to the session.
  * `run_config` – The run config for the agent.

**YIELDS:**

The events generated by the agent.

### `async run_live(*, session, live_request_queue, run_config=RunConfig(speech_config=None, response_modalities=None, save_input_blobs_as_artifacts=False, support_cfc=False, streaming_mode=<StreamingMode.NONE: None>, output_audio_transcription=None, input_audio_transcription=None, max_llm_calls=500))`

Runs the agent in live mode (experimental feature).

**RETURN TYPE:**

`AsyncGenerator[Event, None]`

**PARAMETERS:**

  * `session` – The session to use.
  * `live_request_queue` – The queue for live requests.
  * `run_config` – The run config for the agent.

**YIELDS:**

The events generated by the agent.

**Warning**

This feature is **experimental** and its API or behavior may change in future releases.

### `session_service: BaseSessionService`

The session service for the runner.

-----

# `google.adk.sessions` module

-----

## `class google.adk.sessions.BaseSessionService`

Bases: `ABC`

Base class for session services.

The service provides a set of methods for managing sessions and events.

### `append_event(session, event)`

Appends an event to a session object.

**RETURN TYPE:**

`Event`

### `close_session(*, session)`

Closes a session.

### `abstractmethod create_session(*, app_name, user_id, state=None, session_id=None)`

Creates a new session.

**RETURN TYPE:**

`Session`

**PARAMETERS:**

  * `app_name` – the name of the app.
  * `user_id` – the id of the user.
  * `state` – the initial state of the session.
  * `session_id` – the client-provided id of the session. If not provided, a generated ID will be used.

**RETURNS:**

The newly created session instance.

**RETURN TYPE:**

`session`

### `abstractmethod delete_session(*, app_name, user_id, session_id)`

Deletes a session.

**RETURN TYPE:**

`None`

### `abstractmethod get_session(*, app_name, user_id, session_id, config=None)`

Gets a session.

**RETURN TYPE:**

`Optional[Session]`

### `abstractmethod list_events(*, app_name, user_id, session_id)`

Lists events in a session.

**RETURN TYPE:**

`ListEventsResponse`

### `abstractmethod list_sessions(*, app_name, user_id)`

Lists all the sessions.

**RETURN TYPE:**

`ListSessionsResponse`

-----

## `class google.adk.sessions.DatabaseSessionService(db_url)`

Bases: `BaseSessionService`

A session service that uses a database for storage.

**PARAMETERS:**

  * `db_url` – The database URL to connect to.

### `append_event(session, event)`

Appends an event to a session object.

**RETURN TYPE:**

`Event`

### `create_session(*, app_name, user_id, state=None, session_id=None)`

Creates a new session.

**RETURN TYPE:**

`Session`

**PARAMETERS:**

  * `app_name` – the name of the app.
  * `user_id` – the id of the user.
  * `state` – the initial state of the session.
  * `session_id` – the client-provided id of the session. If not provided, a generated ID will be used.

**RETURNS:**

The newly created session instance.

**RETURN TYPE:**

`session`

### `delete_session(app_name, user_id, session_id)`

Deletes a session.

**RETURN TYPE:**

`None`

### `get_session(*, app_name, user_id, session_id, config=None)`

Gets a session.

**RETURN TYPE:**

`Optional[Session]`

### `list_events(*, app_name, user_id, session_id)`

Lists events in a session.

**RETURN TYPE:**

`ListEventsResponse`

### `list_sessions(*, app_name, user_id)`

Lists all the sessions.

**RETURN TYPE:**

`ListSessionsResponse`

-----

## `class google.adk.sessions.InMemorySessionService`

Bases: `BaseSessionService`

An in-memory implementation of the session service.

### `append_event(session, event)`

Appends an event to a session object.

**RETURN TYPE:**

`Event`

### `create_session(*, app_name, user_id, state=None, session_id=None)`

Creates a new session.

**RETURN TYPE:**

`Session`

**PARAMETERS:**

  * `app_name` – the name of the app.
  * `user_id` – the id of the user.
  * `state` – the initial state of the session.
  * `session_id` – the client-provided id of the session. If not provided, a generated ID will be used.

**RETURNS:**

The newly created session instance.

**RETURN TYPE:**

`session`

### `delete_session(*, app_name, user_id, session_id)`

Deletes a session.

**RETURN TYPE:**

`None`

### `get_session(*, app_name, user_id, session_id, config=None)`

Gets a session.

**RETURN TYPE:**

`Session`

### `list_events(*, app_name, user_id, session_id)`

Lists events in a session.

**RETURN TYPE:**

`ListEventsResponse`

### `list_sessions(*, app_name, user_id)`

Lists all the sessions.

**RETURN TYPE:**

`ListSessionsResponse`

-----

## `pydantic model google.adk.sessions.Session`

Bases: `BaseModel`

Represents a series of interactions between a user and agents.

### `id`

The unique identifier of the session.

### `app_name`

The name of the app.

### `user_id`

The id of the user.

### `state`

The state of the session.

### `events`

The events of the session, e.g. user input, model response, function call/response, etc.

### `last_update_time`

The last update time of the session.

Show JSON schema

**FIELDS:**

  * `app_name` (`str`)
  * `events` (`list[google.adk.events.event.Event]`)
  * `id` (`str`)
  * `last_update_time` (`float`)
  * `state` (`dict[str, Any]`)
  * `user_id` (`str`)

### `field app_name: str [Required]`

The name of the app.

### `field events: list[Event] [Optional]`

The events of the session, e.g. user input, model response, function call/response, etc.

### `field id: str [Required]`

The unique identifier of the session.

### `field last_update_time: float = 0.0`

The last update time of the session.

### `field state: dict[str, Any] [Optional]`

The state of the session.

### `field user_id: str [Required]`

The id of the user.

-----

## `class google.adk.sessions.State(value, delta)`

Bases: `object`

A state dict that maintain the current value and the pending-commit delta.

**PARAMETERS:**

  * `value` – The current value of the state dict.
  * `delta` – The delta change to the current value that hasn’t been committed.

### `APP_PREFIX = 'app:'`

### `TEMP_PREFIX = 'temp:'`

### `USER_PREFIX = 'user:'`

### `get(key, default=None)`

Returns the value of the state dict for the given key.

**RETURN TYPE:**

`Any`

### `has_delta()`

Whether the state has pending delta.

**RETURN TYPE:**

`bool`

### `to_dict()`

Returns the state dict.

**RETURN TYPE:**

`dict[str, Any]`

### `update(delta)`

Updates the state dict with the given delta.

-----

## `class google.adk.sessions.VertexAiSessionService(project=None, location=None)`

Bases: `BaseSessionService`

Connects to the managed Vertex AI Session Service.

### `append_event(session, event)`

Appends an event to a session object.

**RETURN TYPE:**

`Event`

### `create_session(*, app_name, user_id, state=None, session_id=None)`

Creates a new session.

**RETURN TYPE:**

`Session`

**PARAMETERS:**

  * `app_name` – the name of the app.
  * `user_id` – the id of the user.
  * `state` – the initial state of the session.
  * `session_id` – the client-provided id of the session. If not provided, a generated ID will be used.

**RETURNS:**

The newly created session instance.

**RETURN TYPE:**

`session`

### `delete_session(*, app_name, user_id, session_id)`

Deletes a session.

**RETURN TYPE:**

`None`

### `get_session(*, app_name, user_id, session_id, config=None)`

Gets a session.

**RETURN TYPE:**

`Session`

### `list_events(*, app_name, user_id, session_id)`

Lists events in a session.

**RETURN TYPE:**

`ListEventsResponse`

### `list_sessions(*, app_name, user_id)`

Lists all the sessions.

**RETURN TYPE:**

`ListSessionsResponse`

-----

# `google.adk.tools` package

-----

## `class google.adk.tools.APIHubToolset(*, apihub_resource_name, access_token=None, service_account_json=None, name='', description='', lazy_load_spec=False, auth_scheme=None, auth_credential=None, apihub_client=None)`

Bases: `object`

APIHubTool generates tools from a given API Hub resource.

Examples:

```
apihub_toolset = APIHubToolset(
    apihub_resource_name=”projects/test-project/locations/us-central1/apis/test-api”, service_account_json=”…”,
)
# Get all available tools agent = LlmAgent(tools=apihub_toolset.get_tools())
# Get a specific tool agent = LlmAgent(tools=[
    … apihub_toolset.get_tool(‘my_tool’),
])
```

`apihub_resource_name` is the resource name from API Hub. It must include API name, and can optionally include API version and spec name.

  * If apihub\_resource\_name includes a spec resource name, the content of that spec will be used for generating the tools.
  * If apihub\_resource\_name includes only an api or a version name, the first spec of the first version of that API will be used.

Initializes the APIHubTool with the given parameters.

Examples:

```
apihub_toolset = APIHubToolset(
    apihub_resource_name=”projects/test-project/locations/us-central1/apis/test-api”, service_account_json=”…”,
)
# Get all available tools agent = LlmAgent(tools=apihub_toolset.get_tools())
# Get a specific tool agent = LlmAgent(tools=[
    … apihub_toolset.get_tool(‘my_tool’),
])
```

`apihub_resource_name` is the resource name from API Hub. It must include API name, and can optionally include API version and spec name.

  * If apihub\_resource\_name includes a spec resource name, the content of that spec will be used for generating the tools.
  * If apihub\_resource\_name includes only an api or a version name, the first spec of the first version of that API will be used.

Example:

  * `projects/xxx/locations/us-central1/apis/apiname/...`
  * `https://console.cloud.google.com/apigee/api-hub/apis/apiname?project=xxx`

**PARAM APIHUB\_RESOURCE\_NAME:**

The resource name of the API in API Hub. Example: `projects/test-project/locations/us-central1/apis/test-api`.

**PARAM ACCESS\_TOKEN:**

Google Access token. Generate with gcloud cli `gcloud auth auth print-access-token`. Used for fetching API Specs from API Hub.

**PARAM SERVICE\_ACCOUNT\_JSON:**

The service account config as a json string. Required if not using default service credential. It is used for creating the API Hub client and fetching the API Specs from API Hub.

**PARAM APIHUB\_CLIENT:**

Optional custom API Hub client.

**PARAM NAME:**

Name of the toolset. Optional.

**PARAM DESCRIPTION:**

Description of the toolset. Optional.

**PARAM AUTH\_SCHEME:**

Auth scheme that applies to all the tool in the toolset.

**PARAM AUTH\_CREDENTIAL:**

Auth credential that applies to all the tool in the toolset.

**PARAM LAZY\_LOAD\_SPEC:**

If True, the spec will be loaded lazily when needed. Otherwise, the spec will be loaded immediately and the tools will be generated during initialization.

### `get_tool(name)`

Retrieves a specific tool by its name.

**RETURN TYPE:**

`Optional[RestApiTool]`

Example: `apihub_tool = apihub_toolset.get_tool('my_tool')`

**PARAMETERS:**

  * `name` – The name of the tool to retrieve.

**RETURNS:**

The tool with the given name, or None if no such tool exists.

### `get_tools()`

Retrieves all available tools.

**RETURN TYPE:**

`List[RestApiTool]`

**RETURNS:**

A list of all available RestApiTool objects.

-----

## `pydantic model google.adk.tools.AuthToolArguments`

Bases: `BaseModel`

the arguments for the special long running function tool that is used to request end user credentials.

Show JSON schema

**FIELDS:**

  * `auth_config` (`google.adk.auth.auth_tool.AuthConfig`)
  * `function_call_id` (`str`)

### `field auth_config: AuthConfig [Required]`

### `field function_call_id: str [Required]`

-----

## `class google.adk.tools.BaseTool(*, name, description, is_long_running=False)`

Bases: `ABC`

The base class for all tools.

### `description: str`

The description of the tool.

### `is_long_running: bool = False`

Whether the tool is a long running operation, which typically returns a resource id first and finishes the operation later.

### `name: str`

The name of the tool.

### `async process_llm_request(*, tool_context, llm_request)`

Processes the outgoing LLM request for this tool.

Use cases:

  * Most common use case is adding this tool to the LLM request.
  * Some tools may just preprocess the LLM request before it’s sent out.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `tool_context` – The context of the tool.
  * `llm_request` – The outgoing LLM request, mutable this method.

### `async run_async(*, args, tool_context)`

Runs the tool with the given arguments and context.

NOTE :rtype: `Any`

Required if this tool needs to run at the client side. Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for Gemini.

**PARAMETERS:**

  * `args` – The LLM-filled arguments.
  * `tool_context` – The context of the tool.

**RETURNS:**

The result of running the tool.

-----

## `class google.adk.tools.ExampleTool(examples)`

Bases: `BaseTool`

A tool that adds (few-shot) examples to the LLM request.

### `examples`

The examples to add to the LLM request.

### `async process_llm_request(*, tool_context, llm_request)`

Processes the outgoing LLM request for this tool.

Use cases:

  * Most common use case is adding this tool to the LLM request.
  * Some tools may just preprocess the LLM request before it’s sent out.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `tool_context` – The context of the tool.
  * `llm_request` – The outgoing LLM request, mutable this method.

-----

## `class google.adk.tools.FunctionTool(func)`

Bases: `BaseTool`

A tool that wraps a user-defined Python function.

### `func`

The function to wrap.

### `async run_async(*, args, tool_context)`

Runs the tool with the given arguments and context.

NOTE :rtype: `Any`

Required if this tool needs to run at the client side. Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for Gemini.

**PARAMETERS:**

  * `args` – The LLM-filled arguments.
  * `tool_context` – The context of the tool.

**RETURNS:**

The result of running the tool.

-----

## `class google.adk.tools.LongRunningFunctionTool(func)`

Bases: `FunctionTool`

A function tool that returns the result asynchronously.

This tool is used for long-running operations that may take a significant amount of time to complete. The framework will call the function. Once the function returns, the response will be returned asynchronously to the framework which is identified by the `function_call_id`.

Example: `python tool = LongRunningFunctionTool(a_long_running_function)`

### `is_long_running`

Whether the tool is a long running operation.

-----

## `class google.adk.tools.ToolContext(invocation_context, *, function_call_id=None, event_actions=None)`

Bases: `CallbackContext`

The context of the tool.

This class provides the context for a tool invocation, including access to the invocation context, function call ID, event actions, and authentication response. It also provides methods for requesting credentials, retrieving authentication responses, listing artifacts, and searching memory.

### `invocation_context`

The invocation context of the tool.

### `function_call_id`

The function call id of the current tool call. This id was returned in the function call event from LLM to identify a function call. If LLM didn’t return this id, ADK will assign one to it. This id is used to map function call response to the original function call.

### `event_actions`

The event actions of the current tool call.

### `property actions: EventActions`

### `get_auth_response(auth_config)`

**RETURN TYPE:**

`AuthCredential`

### `async list_artifacts()`

Lists the filenames of the artifacts attached to the current session.

**RETURN TYPE:**

`list[str]`

### `request_credential(auth_config)`

**RETURN TYPE:**

`None`

### `async search_memory(query)`

Searches the memory of the current user.

**RETURN TYPE:**

`SearchMemoryResponse`

-----

## `class google.adk.tools.VertexAiSearchTool(*, data_store_id=None, search_engine_id=None)`

Bases: `BaseTool`

A built-in tool using Vertex AI Search.

### `data_store_id`

The Vertex AI search data store resource ID.

### `search_engine_id`

The Vertex AI search engine resource ID.

Initializes the Vertex AI Search tool.

**PARAMETERS:**

  * `data_store_id` – The Vertex AI search data store resource ID in the format of “`projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`”.
  * `search_engine_id` – The Vertex AI search engine resource ID in the format of “`projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`”.

**RAISES:**

`ValueError` – If both data\_store\_id and search\_engine\_id are not specified or both are specified.

### `async process_llm_request(*, tool_context, llm_request)`

Processes the outgoing LLM request for this tool.

Use cases:

  * Most common use case is adding this tool to the LLM request.
  * Some tools may just preprocess the LLM request before it’s sent out.

**RETURN TYPE:**

`None`

**PARAMETERS:**

  * `tool_context` – The context of the tool.
  * `llm_request` – The outgoing LLM request, mutable this method.

-----

## `google.adk.tools.exit_loop(tool_context)`

Exits the loop.

Call this function only when you are instructed to do so.

-----

## `google.adk.tools.transfer_to_agent(agent_name, tool_context)`

Transfer the question to another agent.

-----

## `class google.adk.tools.application_integration_tool.ApplicationIntegrationToolset(project, location, integration=None, triggers=None, connection=None, entity_operations=None, actions=None, tool_name='', tool_instructions='', service_account_json=None)`

Bases: `object`

ApplicationIntegrationToolset generates tools from a given Application Integration or Integration Connector resource.

Example Usage:

```
# Get all available tools for an integration with api trigger application_integration_toolset = ApplicationIntegrationToolset(
    project=”test-project”, location=”us-central1” integration=”test-integration”, trigger=”api_trigger/test_trigger”, service_account_credentials={…},
)
# Get all available tools for a connection using entity operations and # actions # Note: Find the list of supported entity operations and actions for a connection # using integration connector apis: #https://cloud.google.com/integration-connectors/docs/reference/rest/v1/projects.locations.connections.connectionSchemaMetadataapplication_integration_toolset = ApplicationIntegrationToolset(
    project=”test-project”, location=”us-central1” connection=”test-connection”, entity_operations=[“EntityId1”: [“LIST”,”CREATE”], “EntityId2”: []], #empty list for actions means all operations on the entity are supported actions=[“action1”], service_account_credentials={…},
)
# Get all available tools agent = LlmAgent(tools=[
    … *application_integration_toolset.get_tools(),
])
```

Initializes the ApplicationIntegrationToolset.

Example Usage:

```
# Get all available tools for an integration with api trigger application_integration_toolset = ApplicationIntegrationToolset(
    project=”test-project”, location=”us-central1” integration=”test-integration”, triggers=[“api_trigger/test_trigger”], service_account_credentials={…},
)
# Get all available tools for a connection using entity operations and # actions # Note: Find the list of supported entity operations and actions for a connection # using integration connector apis: #https://cloud.google.com/integration-connectors/docs/reference/rest/v1/projects.locations.connections.connectionSchemaMetadataapplication_integration_toolset = ApplicationIntegrationToolset(
    project=”test-project”, location=”us-central1” connection=”test-connection”, entity_operations=[“EntityId1”: [“LIST”,”CREATE”], “EntityId2”: []], #empty list for actions means all operations on the entity are supported actions=[“action1”], service_account_credentials={…},
)
# Get all available tools agent = LlmAgent(tools=[
    … *application_integration_toolset.get_tools(),
])
```

**PARAM PROJECT:**

The GCP project ID.

**PARAM LOCATION:**

The GCP location.

**PARAM INTEGRATION:**

The integration name.

**PARAM TRIGGERS:**

The list of trigger names in the integration.

**PARAM CONNECTION:**

The connection name.

**PARAM ENTITY\_OPERATIONS:**

The entity operations supported by the connection.

**PARAM ACTIONS:**

The actions supported by the connection.

**PARAM TOOL\_NAME:**

The name of the tool.

**PARAM TOOL\_INSTRUCTIONS:**

The instructions for the tool.

**PARAM SERVICE\_ACCOUNT\_JSON:**

The service account configuration as a dictionary. Required if not using default service credential. Used for fetching the Application Integration or Integration Connector resource.

**RAISES VALUEERROR:**

If neither integration and trigger nor connection and (entity\_operations or actions) is provided.

**RAISES EXCEPTION:**

If there is an error during the initialization of the integration or connection client.

### `get_tools()`

**RETURN TYPE:**

`List[RestApiTool]`

-----

## class google.adk.tools.application\_integration\_tool.IntegrationConnectorTool(name, description, connection\_name, connection\_host, connection\_service\_name, entity, operation, action, rest\_api\_tool)

Bases: `BaseTool`

A tool that wraps a `RestApiTool` to interact with a specific Application Integration endpoint.

This tool adds Application Integration specific context like connection details, entity, operation, and action to the underlying REST API call handled by `RestApiTool`. It prepares the arguments and then delegates the actual API call execution to the contained `RestApiTool` instance.

Generates request params and body.
Attaches auth credentials to API call.

**Example:**

```python
# Each API operation in the spec will be turned into its own tool
# Name of the tool is the operationId of that operation, in snake case
operations = OperationGenerator().parse(openapi_spec_dict)
tool = [RestApiTool.from_parsed_operation(o) for o in operations]
```

Initializes the ApplicationIntegrationTool.

**PARAMETERS:**

  * **name** – The name of the tool, typically derived from the API operation. Should be unique and adhere to Gemini function naming conventions (e.g., less than 64 characters).
  * **description** – A description of what the tool does, usually based on the API operation’s summary or description.
  * **connection\_name** – The name of the Integration Connector connection.
  * **connection\_host** – The hostname or IP address for the connection.
  * **connection\_service\_name** – The specific service name within the host.
  * **entity** – The Integration Connector entity being targeted.
  * **operation** – The specific operation being performed on the entity.
  * **action** – The action associated with the operation (e.g., ‘execute’).
  * **rest\_api\_tool** – An initialized `RestApiTool` instance that handles the underlying REST API communication based on an OpenAPI specification operation. This tool will be called by `ApplicationIntegrationTool` with added connection and context arguments.

`tool = [RestApiTool.from_parsed_operation(o) for o in operations]`

`EXCLUDE_FIELDS = ['connection_name', 'service_name', 'host', 'entity', 'operation', 'action']`

`OPTIONAL_FIELDS = ['page_size', 'page_token', 'filter']`

-----

## async run\_async(\*, args, tool\_context)

Runs the tool with the given arguments and context.

**NOTE:** `Dict[str, Any]`

Required if this tool needs to run at the client side.
Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for Gemini.

**PARAMETERS:**

  * **args** – The LLM-filled arguments.
  * **tool\_context** – The context of the tool.

**RETURNS:**

The result of running the tool.

-----

## class google.adk.tools.mcp\_tool.MCPTool(mcp\_tool, mcp\_session, mcp\_session\_manager, auth\_scheme=None, auth\_credential=None)

Bases: `BaseTool`

Turns an MCP Tool into a Vertex Agent Framework Tool.

Internally, the tool initializes from an MCP Tool, and uses the MCP Session to call the tool.

Initializes an `MCPTool`.

This tool wraps an MCP Tool interface and an active MCP Session. It invokes the MCP Tool through executing the tool from a remote MCP Session.

**EXAMPLE**

```python
tool = MCPTool(mcp_tool=mcp_tool, mcp_session=mcp_session)
```

**PARAMETERS:**

  * **mcp\_tool** – The MCP tool to wrap.
  * **mcp\_session** – The MCP session to use to call the tool.
  * **auth\_scheme** – The authentication scheme to use.
  * **auth\_credential** – The authentication credential to use.

**RAISES:**

  * `ValueError` – If `mcp_tool` or `mcp_session` is `None`.

-----

## async run\_async(\*, args, tool\_context)

Runs the tool asynchronously.

**PARAMETERS:**

  * **args** – The arguments as a dict to pass to the tool.
  * **tool\_context** – The tool context from the upper-level ADK agent.

**RETURNS:**

The response from the tool.

**RETURN TYPE:**

Any

-----

## class google.adk.tools.mcp\_tool.MCPToolset(\*, connection\_params, errlog=\<\_io.TextIOWrapper name='\<stderr\>' mode='w' encoding='utf-8'\>, exit\_stack=\<contextlib.AsyncExitStack object\>)

Bases: `object`

Connects to an MCP Server and retrieves MCP Tools into ADK Tools.

**Usage: Example 1 (using `from_server` helper):**

```python
async def load_tools():
    return await MCPToolset.from_server(
        connection_params=StdioServerParameters(
            command='npx', args=["-y", "@modelcontextprotocol/server-filesystem"],
        )
    )

# Use the tools in an LLM agent
tools, exit_stack = await load_tools()
agent = LlmAgent(
    tools=tools
)
await exit_stack.aclose()
```

**Example 2 (using `async with`):**

```python
async def load_tools():
    async with MCPToolset(
        connection_params=SseServerParams(url="http://0.0.0.0:8090/sse")
    ) as toolset:
        tools = await toolset.load_tools()
        agent = LlmAgent(
            ...
            tools=tools
        )
```

**Example 3 (provide `AsyncExitStack`):**

```python
async def load_tools():
    async_exit_stack = AsyncExitStack()
    toolset = MCPToolset(
        connection_params=StdioServerParameters(...),
    )
    async_exit_stack.enter_async_context(toolset)
    tools = await toolset.load_tools()
    agent = LlmAgent(
        ...
    )
    await async_exit_stack.aclose()
```

`connection_params`
The connection parameters to the MCP server. Can be either `StdioServerParameters` or `SseServerParams`.

`exit_stack`
The async exit stack to manage the connection to the MCP server.

`session`
The MCP session being initialized with the connection.

Initializes the `MCPToolset`.

**Usage: Example 1 (using `from_server` helper):**

```python
async def load_tools():
    return await MCPToolset.from_server(
        connection_params=StdioServerParameters(
            command='npx', args=["-y", "@modelcontextprotocol/server-filesystem"],
        )
    )

# Use the tools in an LLM agent
tools, exit_stack = await load_tools()
agent = LlmAgent(
    tools=tools
)
await exit_stack.aclose()
```

**Example 2 (using `async with`):**

```python
async def load_tools():
    async with MCPToolset(
        connection_params=SseServerParams(url="http://0.0.0.0:8090/sse")
    ) as toolset:
        tools = await toolset.load_tools()
        agent = LlmAgent(
            ...
            tools=tools
        )
```

**Example 3 (provide `AsyncExitStack`):**

```python
async def load_tools():
    async_exit_stack = AsyncExitStack()
    toolset = MCPToolset(
        connection_params=StdioServerParameters(...),
    )
    async_exit_stack.enter_async_context(toolset)
    tools = await toolset.load_tools()
    agent = LlmAgent(
        ...
    )
    await async_exit_stack.aclose()
```

**PARAM CONNECTION\_PARAMS:**

The connection parameters to the MCP server. Can be: `StdioServerParameters` for using a local MCP server (e.g., using `npx` or `python3`); or `SseServerParams` for a local/remote SSE server.

-----

## async classmethod from\_server(\*, connection\_params, async\_exit\_stack=None, errlog=\<\_io.TextIOWrapper name='\<stderr\>' mode='w' encoding='utf-8'\>)

Retrieve all tools from the MCP connection.

**RETURN TYPE:**

`Tuple[List[MCPTool], AsyncExitStack]`

**Usage:**

```python
async def load_tools():
    tools, exit_stack = await MCPToolset.from_server(
        connection_params=StdioServerParameters(
            command='npx', args=["-y", "@modelcontextprotocol/server-filesystem"],
        )
    )
```

**PARAMETERS:**

  * **connection\_params** – The connection parameters to the MCP server.
  * **async\_exit\_stack** – The async exit stack to use. If not provided, a new `AsyncExitStack` will be created.

**RETURNS:**

A tuple of the list of `MCPTool`s and the `AsyncExitStack`.

  * **tools**: The list of `MCPTool`s.
  * **async\_exit\_stack**: The `AsyncExitStack` used to manage the connection to the MCP server. Use `await async_exit_stack.aclose()` to close the connection when the server shuts down.

-----

## async load\_tools()

Loads all tools from the MCP Server.

**RETURN TYPE:**

`List[MCPTool]`

**RETURNS:**

A list of `MCPTool`s imported from the MCP Server.

-----

## google.adk.tools.mcp\_tool.adk\_to\_mcp\_tool\_type(tool)

Convert a Tool in ADK into MCP tool type.

This function transforms an ADK tool definition into its equivalent representation in the MCP (Model Context Protocol) system.

**RETURN TYPE:**

Tool

**PARAMETERS:**

  * **tool** – The ADK tool to convert. It should be an instance of a class derived from `BaseTool`.

**RETURNS:**

An object of MCP Tool type, representing the converted tool.

**EXAMPLES**

```python
# Assuming ‘my_tool’ is an instance of a BaseTool derived class
mcp_tool = adk_to_mcp_tool_type(my_tool)
print(mcp_tool)
```

-----

## google.adk.tools.mcp\_tool.gemini\_to\_json\_schema(gemini\_schema)

Converts a Gemini Schema object into a JSON Schema dictionary.

**RETURN TYPE:**

`Dict[str, Any]`

**PARAMETERS:**

  * **gemini\_schema** – An instance of the Gemini Schema class.

**RETURNS:**

A dictionary representing the equivalent JSON Schema.

**RAISES:**

  * `TypeError` – If the input is not an instance of the expected Schema class.
  * `ValueError` – If an invalid Gemini Type enum value is encountered.

-----

## class google.adk.tools.openapi\_tool.OpenAPIToolset(\*, spec\_dict=None, spec\_str=None, spec\_str\_type='json', auth\_scheme=None, auth\_credential=None)

Bases: `object`

Class for parsing OpenAPI spec into a list of `RestApiTool`.

**Usage:**

```python
# Initialize OpenAPI toolset from a spec string.
openapi_toolset = OpenAPIToolset(spec_str=openapi_spec_str, spec_str_type="json")

# Or, initialize OpenAPI toolset from a spec dictionary.
openapi_toolset = OpenAPIToolset(spec_dict=openapi_spec_dict)

# Add all tools to an agent.
agent = Agent(
    tools=[*openapi_toolset.get_tools()]
)
# Or, add a single tool to an agent.
agent = Agent(
    tools=[openapi_toolset.get_tool('tool_name')]
)
```

Initializes the `OpenAPIToolset`.

**Usage:**

```python
# Initialize OpenAPI toolset from a spec string.
openapi_toolset = OpenAPIToolset(spec_str=openapi_spec_str, spec_str_type="json")

# Or, initialize OpenAPI toolset from a spec dictionary.
openapi_toolset = OpenAPIToolset(spec_dict=openapi_spec_dict)

# Add all tools to an agent.
agent = Agent(
    tools=[*openapi_toolset.get_tools()]
)
# Or, add a single tool to an agent.
agent = Agent(
    tools=[openapi_toolset.get_tool('tool_name')]
)
```

**PARAMETERS:**

  * **spec\_dict** – The OpenAPI spec dictionary. If provided, it will be used instead of loading the spec from a string.
  * **spec\_str** – The OpenAPI spec string in JSON or YAML format. It will be used when `spec_dict` is not provided.
  * **spec\_str\_type** – The type of the OpenAPI spec string. Can be "json" or "yaml".
  * **auth\_scheme** – The auth scheme to use for all tools. Use `AuthScheme` or use helpers in `google.adk.tools.openapi_tool.auth.auth_helpers`.
  * **auth\_credential** – The auth credential to use for all tools. Use `AuthCredential` or use helpers in `google.adk.tools.openapi_tool.auth.auth_helpers`.

-----

## get\_tool(tool\_name)

Get a tool by name.

**RETURN TYPE:**

`Optional[RestApiTool]`

-----

## get\_tools()

Get all tools in the toolset.

**RETURN TYPE:**

`List[RestApiTool]`

-----

## class google.adk.tools.openapi\_tool.RestApiTool(name, description, endpoint, operation, auth\_scheme=None, auth\_credential=None, should\_parse\_operation=True)

Bases: `BaseTool`

A generic tool that interacts with a REST API.

Generates request params and body.
Attaches auth credentials to API call.

**Example:**

```python
# Each API operation in the spec will be turned into its own tool
# Name of the tool is the operationId of that operation, in snake case
operations = OperationGenerator().parse(openapi_spec_dict)
tool = [RestApiTool.from_parsed_operation(o) for o in operations]
```

Initializes the `RestApiTool` with the given parameters.

To generate `RestApiTool` from OpenAPI Specs, use `OperationGenerator`.

**Example:**

```python
# Each API operation in the spec will be turned into its own tool
# Name of the tool is the operationId of that operation, in snake case
operations = OperationGenerator().parse(openapi_spec_dict)
tool = [RestApiTool.from_parsed_operation(o) for o in operations]
```

**Hint:** Use `google.adk.tools.openapi_tool.auth.auth_helpers` to construct `auth_scheme` and `auth_credential`.

**PARAMETERS:**

  * **name** – The name of the tool.
  * **description** – The description of the tool.
  * **endpoint** – Include the base\_url, path, and method of the tool.
  * **operation** – Pydantic object or a dict. Representing the OpenAPI Operation object ([https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md\#operation-object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#operation-object))
  * **auth\_scheme** – The auth scheme of the tool. Representing the OpenAPI SecurityScheme object ([https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md\#security-scheme-object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#security-scheme-object))
  * **auth\_credential** – The authentication credential of the tool.
  * **should\_parse\_operation** – Whether to parse the operation.

-----

## call(\*, args, tool\_context)

Executes the REST API call.

**RETURN TYPE:**

`Dict[str, Any]`

**PARAMETERS:**

  * **args** – Keyword arguments representing the operation parameters.
  * **tool\_context** – The tool context (not used here, but required by the interface).

**RETURNS:**

The API response as a dictionary.

-----

## configure\_auth\_credential(auth\_credential=None)

Configures the authentication credential for the API call.

**PARAMETERS:**

  * **auth\_credential** – `AuthCredential` or `dict` - The authentication credential. The dict is converted to an `AuthCredential` object.

-----

## configure\_auth\_scheme(auth\_scheme)

Configures the authentication scheme for the API call.

**PARAMETERS:**

  * **auth\_scheme** – `AuthScheme` or `dict` - The authentication scheme. The dict is converted to an `AuthScheme` object.

-----

## classmethod from\_parsed\_operation(parsed)

Initializes the `RestApiTool` from a `ParsedOperation` object.

**RETURN TYPE:**

`RestApiTool`

**PARAMETERS:**

  * **parsed** – A `ParsedOperation` object.

**RETURNS:**

A `RestApiTool` object.

-----

## classmethod from\_parsed\_operation\_str(parsed\_operation\_str)

Initializes the `RestApiTool` from a dict.

**RETURN TYPE:**

`RestApiTool`

**PARAMETERS:**

  * **parsed** – A dict representation of a `ParsedOperation` object.

**RETURNS:**

A `RestApiTool` object.

-----

## async run\_async(\*, args, tool\_context)

Runs the tool with the given arguments and context.

**NOTE:** `Dict[str, Any]`

Required if this tool needs to run at the client side.
Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for Gemini.

**PARAMETERS:**

  * **args** – The LLM-filled arguments.
  * **tool\_context** – The context of the tool.

**RETURNS:**

The result of running the tool.

-----

## class google.adk.tools.retrieval.BaseRetrievalTool(\*, name, description, is\_long\_running=False)

Bases: `BaseTool`

-----

## class google.adk.tools.retrieval.FilesRetrieval(\*, name, description, input\_dir)

Bases: `LlamaIndexRetrieval`

-----

## class google.adk.tools.retrieval.LlamaIndexRetrieval(\*, name, description, retriever)

Bases: `BaseRetrievalTool`

-----

## async run\_async(\*, args, tool\_context)

Runs the tool with the given arguments and context.

**NOTE:** `Any`

Required if this tool needs to run at the client side.
Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for Gemini.

**PARAMETERS:**

  * **args** – The LLM-filled arguments.
  * **tool\_context** – The context of the tool.

**RETURNS:**

The result of running the tool.

-----

## class google.adk.tools.retrieval.VertexAiRagRetrieval(\*, name, description, rag\_corpora=None, rag\_resources=None, similarity\_top\_k=None, vector\_distance\_threshold=None)

Bases: `BaseRetrievalTool`

A retrieval tool that uses Vertex AI RAG (Retrieval-Augmented Generation) to retrieve data.

-----

## async process\_llm\_request(\*, tool\_context, llm\_request)

Processes the outgoing LLM request for this tool.

**Use cases:**

  * Most common use case is adding this tool to the LLM request.
  * Some tools may just preprocess the LLM request before it’s sent out.

**RETURN TYPE:**

None

**PARAMETERS:**

  * **tool\_context** – The context of the tool.
  * **llm\_request** – The outgoing LLM request, mutable in this method.

-----

## async run\_async(\*, args, tool\_context)

Runs the tool with the given arguments and context.

**NOTE:** `Any`

Required if this tool needs to run at the client side.
Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for Gemini.

**PARAMETERS:**

  * **args** – The LLM-filled arguments.
  * **tool\_context** – The context of the tool.

**RETURNS:**

The result of running the tool.